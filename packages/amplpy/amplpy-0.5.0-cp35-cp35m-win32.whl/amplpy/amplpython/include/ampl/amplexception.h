#ifndef AMPL_AMPLEXCEPTION_H
#define AMPL_AMPLEXCEPTION_H

#include <stdexcept>
#include <string>
#include <cstdlib>

#include "ampl/format.h"

namespace ampl {

/**
 * Represent an exception generated by %AMPL
 */
class AMPLException : public std::runtime_error {
public:
   /**
  Copy constructor
  */
  AMPLException(const AMPLException &e) :
    std::runtime_error(e.what()), filename_(strdup(e.filename_)),
    line_(e.line_), offset_(e.offset_), message_(strdup(e.message_)) {
  }

  /**
  Default constructor
  */
  explicit AMPLException() :
    std::runtime_error(""), filename_(strdup("")), line_(-1), offset_(-1), message_(strdup("")) {
  }

  /**
  Constructor
  \param cause Cause of the exception
  */
  explicit AMPLException(fmt::CStringRef cause) :
    std::runtime_error(cause.c_str()), filename_(strdup("")), line_(-1), offset_(-1), message_(strdup("")) {
    parseMessage(cause);
  }

  /**
  Constructor for %AMPL errors
  \param filename Name of the file in which the exception occurred
  \param row Row where the error is detected
  \param offset Offset where the error is detected
  \param message Message to be embedded in the exception
  */
  AMPLException(fmt::CStringRef filename, int row, int offset, fmt::CStringRef message) :
    std::runtime_error(getWhat(filename.c_str(), row, offset, message.c_str())),
    filename_(strdup(filename.c_str())), line_(row), offset_(offset),
    message_(strdup(message.c_str())) {
  }

  /**
  Here to avoid the error looser throw specifier for virtual
  AMPLException::~AMPLException()
  in some old c++ compilers
  */
  ~AMPLException() throw() {
    // FIXME: Causes segmentation fault
    /*free(message_);
    message_ = NULL;
    free(filename_);
    filename_ = NULL;*/
  }

  /**
  Get the name of the file where the error was detected
  */
  std::string getSourceName() const { return std::string(filename_); }

  /**
  Get the row where the error is located
  */
  int getLineNumber() const { return line_; }

  /**
  Get the offset where the error is located
  */
  int getOffset() const { return offset_; }

  /**
  Get the error message
  */
  std::string getMessage() const { return std::string(message_); }
  /**
  Overwrites the source name for this error
  */
  void setSourceName(const std::string& sourceName) {
    free(filename_);
    filename_ = strdup(sourceName.c_str());
  }
private:
  char *filename_;
  int line_;
  int offset_;
  char *message_;
  char *strdup(const char *str) {
    if(str == NULL) return NULL;
    std::size_t len = std::strlen(str);
    char *dst = (char *)malloc(len+1);
    if(dst) std::memcpy(dst, str, len+1);
    return dst;
  }
  static std::string getWhat(fmt::StringRef filename, int row, int offset,
                             fmt::StringRef message) {
    fmt::MemoryWriter out;
    if (filename.size() > 0) out << "file " << filename << "\n";
    out << "line " << row << " offset " << offset << "\n";
    out << message << "\n";
    return out.str();
  }
  template <std::size_t SIZE>
  const char *skip(const char *&cursor, const char(&str)[SIZE]) {
    const char *s = std::strstr(cursor, str);
    if (s)
      cursor = s + SIZE - 1;
    return s;
  }
  template <std::size_t SIZE>
  int getIntegerAfterMarker(const char *&cursor, const char(&marker)[SIZE])
  {
    int value = 0;
    char* end = 0;
    if (skip(cursor, marker)) {
      value = std::strtol(cursor, &end, 10);
      cursor = end;
    }
    return value;
  }
  void parseMessage(fmt::CStringRef msg)
  {
    try {
      const char* cursor = msg.c_str();
      if (skip(cursor, "file ")) {
        if (const char *end = std::strchr(cursor, '\n')) {
          free(filename_);
          filename_ = NULL;
          filename_ = strdup(std::string(cursor, end).c_str());
          cursor = end + 1;
        }
        line_ = getIntegerAfterMarker(cursor, "line ");
        offset_ = getIntegerAfterMarker(cursor, "offset ");
        skip(cursor, "\n");
      }
      free(message_);
      message_ = NULL;
      message_ = strdup(std::string(cursor, cursor + std::strlen(cursor) - 1).c_str());
    }
    catch (...)
    {
      free(message_);
      message_ = NULL;
      message_ = strdup(msg.c_str());
    }
  }
};
/**
* Thrown if AMPL could not be started because of licensing errors
*/
class LicenseException : public std::runtime_error {
public:
  LicenseException(fmt::CStringRef cause) : std::runtime_error(cause.c_str()) {}
};

/**
* Thrown if a file could not be found
*/
class FileIOException : public std::runtime_error {
public:
  FileIOException(fmt::CStringRef cause) : std::runtime_error(cause.c_str()) {}
};

/**
Thrown when accessing entities with the wrong number of indices,
e.g. accessing an indexed entity with Entity.get()
*/
class UnsupportedOperationException : public std::runtime_error
{
public:
  UnsupportedOperationException(fmt::CStringRef cause) : std::runtime_error(cause.c_str()) {}
};
/**
Thrown when an invalid subscript is accessed
*/
class InvalidSubscriptException : public AMPLException
{
public:
  InvalidSubscriptException(fmt::CStringRef filename, int row, int offset,
    fmt::CStringRef message) : AMPLException(filename, row, offset, message) {}
};
/**
Thrown when a syntax error is detected
*/
class SyntaxErrorException : public AMPLException
{
public:
  SyntaxErrorException(fmt::CStringRef filename, int row, int offset,
    fmt::CStringRef message) : AMPLException(filename, row, offset, message) {}
};
/**
Thrown when an entity is accessed when no data has been
assigned yet
*/
class NoDataException : public std::runtime_error
{
public:
  NoDataException(fmt::CStringRef msg) : 
    std::runtime_error(msg.c_str())
  {}
};

}

#endif
