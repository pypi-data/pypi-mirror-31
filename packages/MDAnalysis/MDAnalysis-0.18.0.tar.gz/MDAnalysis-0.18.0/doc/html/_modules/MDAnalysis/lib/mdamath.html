
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>MDAnalysis.lib.mdamath &#8212; MDAnalysis 0.17.1-dev documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.17.1-dev documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.lib.mdamath</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Mathematical helper functions --- :mod:`MDAnalysis.lib.mdamath`</span>
<span class="sd">===============================================================</span>

<span class="sd">Helper functions for common mathematical operations</span>

<span class="sd">.. autofunction:: normal</span>
<span class="sd">.. autofunction:: norm</span>
<span class="sd">.. autofunction:: angle</span>
<span class="sd">.. autofunction:: dihedral</span>
<span class="sd">.. autofunction:: stp</span>
<span class="sd">.. autofunction:: triclinic_box</span>
<span class="sd">.. autofunction:: triclinic_vectors</span>
<span class="sd">.. autofunction:: box_volume</span>
<span class="sd">.. autofunction:: make_whole</span>

<span class="sd">.. versionadded:: 0.11.0</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">zip</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="k">import</span> <span class="n">NoDataError</span>


<span class="c1"># geometric functions</span>
<div class="viewcode-block" id="norm"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.norm">[docs]</a><span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Calculate the norm of a vector v.</span>

<span class="sd">    .. math:: v = \sqrt{\mathbf{v}\cdot\mathbf{v}}</span>

<span class="sd">    This version is faster then numpy.linalg.norm because it only works for a</span>
<span class="sd">    single vector and therefore can skip a lot of the additional fuss</span>
<span class="sd">    linalg.norm does.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like</span>
<span class="sd">        1D array of shape (N) for a vector of length N</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        norm of the vector</span>

<span class="sd">    &quot;&quot;&quot;</span></div>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>


<div class="viewcode-block" id="normal"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.normal">[docs]</a><span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Returns the unit vector normal to two vectors.</span>

<span class="sd">    .. math::</span>

<span class="sd">       \hat{\mathbf{n}} = \frac{\mathbf{v}_1 \times \mathbf{v}_2}{|\mathbf{v}_1 \times \mathbf{v}_2|}</span>

<span class="sd">    If the two vectors are collinear, the vector :math:`\mathbf{0}` is returned.</span>

<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Moved into lib.mdamath</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">normal</span>  <span class="c1"># returns [0,0,0] instead of [nan,nan,nan]</span></div>
    <span class="k">return</span> <span class="n">normal</span> <span class="o">/</span> <span class="n">n</span>  <span class="c1"># ... could also use numpy.nan_to_num(normal/norm(normal))</span>


<div class="viewcode-block" id="angle"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.angle">[docs]</a><span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the angle between two vectors in radians</span>

<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Moved into lib.mdamath</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="c1"># catch roundoffs that lead to nan otherwise</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span></div>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<div class="viewcode-block" id="stp"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.stp">[docs]</a><span class="k">def</span> <span class="nf">stp</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">vec3</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Takes the scalar triple product of three vectors.</span>

<span class="sd">    Returns the volume *V* of the parallel epiped spanned by the three</span>
<span class="sd">    vectors</span>

<span class="sd">    .. math::</span>

<span class="sd">        V = \mathbf{v}_3 \cdot (\mathbf{v}_1 \times \mathbf{v}_2)</span>

<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Moved into lib.mdamath</span>
<span class="sd">    &quot;&quot;&quot;</span></div>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">))</span>


<div class="viewcode-block" id="dihedral"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.dihedral">[docs]</a><span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Returns the dihedral angle in radians between vectors connecting A,B,C,D.</span>

<span class="sd">    The dihedral measures the rotation around bc::</span>

<span class="sd">         ab</span>
<span class="sd">       A----&gt;B</span>
<span class="sd">              \ bc</span>
<span class="sd">              _\&#39;</span>
<span class="sd">                C----&gt;D</span>
<span class="sd">                  cd</span>

<span class="sd">    The dihedral angle is restricted to the range -π &lt;= x &lt;= π.</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Moved into lib.mdamath</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">normal</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">),</span> <span class="n">normal</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">))</span></div>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">stp</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Angle between two vectors *a* and *b* in degrees.</span>

<span class="sd">    If one of the lengths is 0 then the angle is returned as 0</span>
<span class="sd">    (instead of `nan`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This function has different limits than angle?</span>

    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>


<div class="viewcode-block" id="triclinic_box"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.triclinic_box">[docs]</a><span class="k">def</span> <span class="nf">triclinic_box</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the three triclinic box vectors to [A,B,C,alpha,beta,gamma].</span>

<span class="sd">    Angles are in degrees.</span>

<span class="sd">    * alpha  = angle(y,z)</span>
<span class="sd">    * beta   = angle(x,z)</span>
<span class="sd">    * gamma  = angle(x,y)</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Definition of angles: http://en.wikipedia.org/wiki/Lattice_constant</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">_angle</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">_angle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">_angle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>


<div class="viewcode-block" id="triclinic_vectors"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.triclinic_vectors">[docs]</a><span class="k">def</span> <span class="nf">triclinic_vectors</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert `[A,B,C,alpha,beta,gamma]` to a triclinic box representation.</span>

<span class="sd">    Original `code by Tsjerk Wassenaar`_ posted on the Gromacs mailinglist.</span>

<span class="sd">    If *dimensions* indicates a non-periodic system (i.e. all lengths</span>
<span class="sd">    0) then null-vectors are returned.</span>

<span class="sd">    .. _code by Tsjerk Wassenaar:</span>
<span class="sd">       http://www.mail-archive.com/gmx-users@gromacs.org/msg28032.html</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : [A, B, C, alpha, beta, gamma]</span>
<span class="sd">        list of box lengths and angles (in degrees) such as</span>
<span class="sd">        ``[A,B,C,alpha,beta,gamma]``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.array</span>
<span class="sd">        numpy 3x3 array B, with ``B[0]`` as first box vector,</span>
<span class="sd">        ``B[1]``as second vector, ``B[2]`` as third box vector.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The first vector is always pointing along the X-axis,</span>
<span class="sd">    i.e., parallel to (1, 0, 0).</span>


<span class="sd">    .. versionchanged:: 0.7.6</span>
<span class="sd">       Null-vectors are returned for non-periodic (or missing) unit cell.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">B</span>

    <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mf">90.</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="mf">90.</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">:</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">z</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>
    <span class="k">return</span> <span class="n">B</span>


<div class="viewcode-block" id="box_volume"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.box_volume">[docs]</a><span class="k">def</span> <span class="nf">box_volume</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the volume of the unitcell described by *dimensions*.</span>

<span class="sd">    The volume is computed as `det(x1,x2,x2)` where the xi are the</span>
<span class="sd">    triclinic box vectors from :func:`triclinic_vectors`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : [A, B, C, alpha, beta, gamma]</span>
<span class="sd">        list of box lengths and angles (in degrees) such as</span>
<span class="sd">        [A,B,C,alpha,beta,gamma]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    volume : float</span>
<span class="sd">    &quot;&quot;&quot;</span></div>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">triclinic_vectors</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_is_contiguous</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Walk through atomgroup, starting with atom.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        ``True`` if all of *atomgroup* is accessible through walking</span>
<span class="sd">        along bonds.</span>
<span class="sd">        ``False`` otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">atom</span><span class="p">])</span>
    <span class="n">walked</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">ag_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">)</span>

    <span class="n">nloops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">seen</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">):</span>
        <span class="n">nloops</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">nloops</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">todo</span> <span class="o">=</span> <span class="n">seen</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">walked</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonded_atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">ag_set</span><span class="p">:</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">walked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="make_whole"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.make_whole">[docs]</a><span class="k">def</span> <span class="nf">make_whole</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">,</span> <span class="n">reference_atom</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Move all atoms in a single molecule so that bonds don&#39;t split over images</span>

<span class="sd">    Atoms are modified in place.</span>

<span class="sd">    This function is most useful when atoms have been packed into the primary</span>
<span class="sd">    unit cell, causing breaks mid molecule, with the molecule then appearing</span>
<span class="sd">    on either side of the unit cell. This is problematic for operations</span>
<span class="sd">    such as calculating the center of mass of the molecule. ::</span>

<span class="sd">       +-----------+     +-----------+</span>
<span class="sd">       |           |     |           |</span>
<span class="sd">       | 6       3 |     |         3 | 6</span>
<span class="sd">       | !       ! |     |         ! | !</span>
<span class="sd">       |-5-8   1-2-| -&gt;  |       1-2-|-5-8</span>
<span class="sd">       | !       ! |     |         ! | !</span>
<span class="sd">       | 7       4 |     |         4 | 7</span>
<span class="sd">       |           |     |           |</span>
<span class="sd">       +-----------+     +-----------+</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    atomgroup : AtomGroup</span>
<span class="sd">        The :class:`MDAnalysis.core.groups.AtomGroup` to work with.</span>
<span class="sd">        The positions of this are modified in place.  All these atoms</span>
<span class="sd">        must belong in the same molecule or fragment.</span>
<span class="sd">    reference_atom : :class:`~MDAnalysis.core.groups.Atom`</span>
<span class="sd">        The atom around which all other atoms will be moved.</span>
<span class="sd">        Defaults to atom 0 in the atomgroup.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NoDataError</span>
<span class="sd">        There are no bonds present.</span>
<span class="sd">        (See :func:`~MDAnalysis.topology.core.guess_bonds`)</span>

<span class="sd">    ValueError</span>
<span class="sd">        The algorithm fails to work.  This is usually</span>
<span class="sd">        caused by the atomgroup not being a single fragment.</span>
<span class="sd">        (ie the molecule can&#39;t be traversed by following bonds)</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Only orthogonal boxes are currently supported.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Make fragments whole::</span>

<span class="sd">        from MDAnalysis.util.mdamath import make_whole</span>

<span class="sd">        # This algorithm requires bonds, these can be guessed!</span>
<span class="sd">        u = mda.Universe(......, guess_bonds=True)</span>

<span class="sd">        # MDAnalysis can split molecules into their fragments</span>
<span class="sd">        # based on bonding information.</span>
<span class="sd">        # Note that this function will only handle a single fragment</span>
<span class="sd">        # at a time, necessitating a loop.</span>
<span class="sd">        for frag in u.fragments:</span>
<span class="sd">          make_whole(frag)</span>

<span class="sd">    Alternatively, to keep a single atom in place as the anchor::</span>

<span class="sd">        # This will mean that atomgroup[10] will NOT get moved,</span>
<span class="sd">        # and all other atoms will move (if necessary).</span>
<span class="sd">        make_whole(atomgroup, reference_atom=atomgroup[10])</span>


<span class="sd">    .. versionadded:: 0.11.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">bonds</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;The atomgroup is required to have bonds&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">reference_atom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">reference_atom</span>
        <span class="c1"># Sanity check</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">atomgroup</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reference atom not in atomgroup&quot;</span><span class="p">)</span>

    <span class="c1"># Check all of atomgroup is accessible from ref</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_contiguous</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;atomgroup not contiguous from bonds&quot;</span><span class="p">)</span>

    <span class="c1"># Not sure if this is actually a requirement...</span>
    <span class="c1"># I think application of pbc would need to be changed for triclinic boxes</span>
    <span class="c1"># but that&#39;s all?  How does minimum bond length criteria change?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="mf">90.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non orthogonal boxes are not supported&quot;</span><span class="p">)</span>
    <span class="n">box</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">box</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Supplied box had zero size&quot;</span><span class="p">)</span>

    <span class="n">box_length</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="n">bondlengths</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">bonds</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bondlengths</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1.4</span> <span class="o">&gt;</span> <span class="n">box_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Box lengths are too small relative to bond lengths&quot;</span><span class="p">)</span>

    <span class="c1"># All checks done, let&#39;s continue</span>
    <span class="c1"># If bond lengths don&#39;t change after pbc applied, then no bonds</span>
    <span class="c1"># straddle the box boundaries</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">bonds</span><span class="p">(),</span> <span class="n">bondlengths</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="c1"># Can&#39;t reuse this calculation of bond lengths as we&#39;re changing</span>
    <span class="c1"># stuff as we go.</span>

    <span class="n">processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Who have I already done?</span>
    <span class="n">ref_points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">ref</span><span class="p">])</span>  <span class="c1"># Who is safe to use as reference point?</span>

    <span class="n">ag_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">)</span>
    <span class="n">nres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">)</span>  <span class="c1"># total size of the problem</span>
    <span class="n">nloops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nres</span><span class="p">:</span>  <span class="c1"># While all atoms aren&#39;t correct</span>
        <span class="n">nloops</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">nloops</span> <span class="o">&gt;</span> <span class="n">nres</span><span class="p">:</span>  <span class="c1"># To prevent infinite loop</span>
            <span class="c1"># This point probable isn&#39;t reachable with the above _is_contiguous</span>
            <span class="c1"># check, but better safe than sorry.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Algorithm couldn&#39;t traverse atomgroup. &quot;</span>
                             <span class="s2">&quot;Perhaps the atomgroup isn&#39;t fully connected&quot;</span><span class="p">)</span>

        <span class="c1"># We want to iterate over atoms that are good to use as reference</span>
        <span class="c1"># points, but haven&#39;t been processed yet.</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="n">ref_points</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                <span class="c1"># Avoid atoms not in our scope</span>
                <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ag_set</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">ref_points</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">box_length</span><span class="p">:</span>
                    <span class="c1"># Vector from ref atom to other</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">ref</span><span class="o">.</span><span class="n">position</span>
                    <span class="c1"># Apply pbc to this vector</span>
                    <span class="n">vec</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">vec</span><span class="o">/</span><span class="n">box</span><span class="p">)</span> <span class="o">*</span> <span class="n">box</span>
                    <span class="c1"># Define the position of other based on this vector</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">vec</span>
                <span class="c1"># This atom can now be used as a reference point</span>
                <span class="n">ref_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</div>
            <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>


<div class="viewcode-block" id="one_to_many_pointers"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.one_to_many_pointers">[docs]</a><span class="k">def</span> <span class="nf">one_to_many_pointers</span><span class="p">(</span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nj</span><span class="p">,</span> <span class="n">i2j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Based on a many to one mapping of i to j, create the reverse mapping</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    Ni : int</span>
<span class="sd">       number of i  components</span>
<span class="sd">    Nj : int</span>
<span class="sd">       number of j components</span>
<span class="sd">    i2j : numpy.ndarray</span>
<span class="sd">       relates i to parent js</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ordered : list</span>
<span class="sd">       an ordered list of i indices [size (i,)]</span>
<span class="sd">    ptrs : list</span>
<span class="sd">       the start and end index for each j [size (Nj, 2)]</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    .. code:: python</span>

<span class="sd">        # Residx - the resid of each Atom</span>
<span class="sd">        ordered, ptrs = one_to_many_pointers(Natoms, Nres, Residx)</span>

<span class="sd">        # Returns an array of the atom indices that are in resid 7</span>
<span class="sd">        atoms = ordered[ptrs[7,0]:ptrs[7,1]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ordered</span> <span class="o">=</span> <span class="n">i2j</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">i2j</span><span class="p">[</span><span class="n">ordered</span><span class="p">]</span>
    <span class="n">borders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sorted_idx</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="p">[</span><span class="n">Ni</span><span class="p">]])</span>

    <span class="n">ptrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nj</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">borders</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">sorted_idx</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">ptrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</div>
    <span class="k">return</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">ptrs</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logos/mdanalysis-logo-200x150.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=MDAnalysis&repo=mdanalysis&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/loading_files.html">2. Loading your data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">3. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">4. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">5. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">6. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">7. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">8. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">9. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">10. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">11. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">12. Library functions — <code class="docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">13. Version information for MDAnalysis - <code class="docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">14. Constants and unit conversion — <code class="docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">15. Custom exceptions and warnings — <code class="docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">16. References</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2005-2017, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Shobhit Agarwal, Balasubramanian, Utkarsh Bansal, Jonathan Barnoud, Tone Bengtsen, Alejandro Bernardin, Mateusz Bieniek, Wouter Boomsma, Jose Borreguero, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, David Caplan, Matthieu Chavent, Kathleen Clark, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Benjamin Hall, Eugen Hruska, Kyle J. Huston, Joe Jordan, Jon Kapla, Andrew William King, Max Linke, Jinju Lu, Micaela Matta, Robert McGibbon, Manuel Nuno Melo, Dominik 'Rathann' Mierzejewski, Fiona Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Nabarun Pal, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Vedant Rathore, Tyler Reddy, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Andy Somogyi, Caio S. Souza, Shantanu Srivastava, Lukas Stelzl, Gorman Stock, Matteo Tiberti, Isaac Virshup, Nestor Wendt, Zhiyi Wu, Zhuyi Xue, Juan Eiros Zamora, and Oliver Beckstein.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    
    <a href="https://github.com/MDAnalysis/mdanalysis" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>