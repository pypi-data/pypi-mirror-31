""" 
Coconut threshold credentials scheme. 
"""
from bplib.bp import BpGroup, G2Elem
from coconut.utils import *
from coconut.proofs import *


def setup(q=1):
	"""
	Generate the public parameters. 

	Parameters:
		- `q` (integer): the maximum number of attributes that can be embbed in the credentials

	Returns:
		- params: the publc parameters
	"""
	assert q > 0
	G = BpGroup()
	(g1, g2) = G.gen1(), G.gen2()
	hs = [G.hashG1(("h%s" % i).encode("utf8")) for i in range(q)]
	(e, o) = G.pair, G.order()
	return (G, o, g1, hs, g2, e)


def ttp_keygen(params, t, n):
	"""
	Generate keys for threshold signature (executed by a TTP).

	Parameters:
		- `params`: public parameters generated by `setup`
		- `t` (integer): the threshold parameter
		- `n` (integer): the total number of authorities
		- `q` (integer): the maximum number of attributes that can be embbed in the credentials

	Returns:
		- `sk` [Bn]: array containing the secret key of each authority
		- `vk` [(G2Elem, G2Elem, [G2Elem])]: array containing the verification key of each authority
	"""
	(G, o, g1, hs, g2, e) = params
	q = len(hs)
	assert n >= t and t > 0 and q > 0
	# generate polynomials
	v = [o.random() for _ in range(0,t)]
	w = [[o.random() for _ in range(0,t)] for __ in range(q)]
	# generate shares
	x = [poly_eval(v,i) % o for i in range(1,n+1)]
	y = [[poly_eval(wj,i) % o for wj in w] for i in range(1,n+1)]
	# set keys
	sk = list(zip(x, y))
	vk = [(g2, x[i]*g2, [y[i][j]*g2 for j in range(len(y[i]))]) for i in range(len(sk))]
	return (sk, vk)


def aggregate_vk(params, vk, threshold=True):
	""" 
	Aggregate the verification keys.

	Parameters:
		- `params`: public parameters generated by `setup`
		- `vk` [(G2Elem, G2Elem, [G2Elem])]: array containing the verification key of each authority
		- `threshold` (bool): optional, whether to use threshold cryptography or not

	Returns:
		- `aggr_vk` (G2Elem, G2Elem, [G2Elem]): aggregated verification key
	"""
	(G, o, g1, hs, g2, e) = params
	(_, alpha, beta) = zip(*vk)
	t = len(vk)
	q = len(beta[0])
	# evaluate all lagrange basis polynomial li(0)
	l = [lagrange_basis(t, o, i, 0) for i in range(1,t+1)] if threshold else [1 for _ in range(t)]
	# aggregate keys
	aggr_alpha = ec_sum([l[i]*alpha[i] for i in range(t)])
	aggr_beta = [ec_sum([l[i]*beta[i][j] for i in range(t)]) for j in range(q)]
	return (g2, aggr_alpha, aggr_beta)


def prepare_blind_sign(params, gamma, private_m, public_m=[]):
	""" 
	Build cryptographic material for blind sign.

	Parameters:
		- `params`: public parameters generated by `setup`
		- `gamma` (G1Elem): the user's El-Gamal public key
		- `private_m` [Bn]: array containing the private attributes
		- `public_m` [Bn]: optional, array containing the public attributes

	Returns:
		- `cm` (G1Elem): commitment to the private and public attributes
		- `c` (G1Elem, G1Elem): El-Gamal encryption of the private attributes 
		- `pi_s`: zero-knowledge proof asserting correctness of `cm` and `c`
	"""
	assert len(private_m) > 0
	(G, o, g1, hs, g2, e) = params
	attributes = private_m + public_m
	assert len(attributes) <= len(hs)
	# build commitment
	r = o.random()
	cm = r*g1 + ec_sum([attributes[i]*hs[i] for i in range(len(attributes))])
	# build El Gamal encryption
	h = G.hashG1(cm.export()) 
	enc = [elgamal_enc(params, gamma, m, h) for m in private_m]
	(a, b, k) = zip(*enc)
	c = list(zip(a, b))
	# build proofs
	pi_s = make_pi_s(params, gamma, c, cm, k, r, public_m, private_m)
	return (cm, c, pi_s)


def blind_sign(params, sk, cm, c, gamma, pi_s, public_m=[]):
	""" 
	Blindly sign private attributes. 

	Parameters:
		- `params`: public parameters generated by `setup`
		- `sk` (Bn, Bn): the secret key of the authority 
		- `cm` (G1Elem): commitment to the private and public attributes
		- `c` (G1Elem, G1Elem): El-Gamal encryption of the private attributes 
		- `gamma` (G1Elem): the user's El-Gamal public key
		- `pi_s`: zero-knowledge proof asserting correctness of `cm` and `c`
		- `public_m` [Bn]: optional, array containing the public attributes

	Returns:
		- `sigma_tilde` (G1Elem, G1Elem): blinded credential
	"""
	(G, o, g1, hs, g2, e) = params
	(x, y) = sk
	(a, b) = zip(*c) 
	assert (len(c)+len(public_m)) <= len(hs)
	# verify proof of correctness
	assert verify_pi_s(params, gamma, c, cm, pi_s)
	# issue signature
	h = G.hashG1(cm.export())
	t1 = [mi*h for mi in public_m]
	t2 = ec_sum([yi*ai for yi,ai in zip(y,a)])
	t3 = x*h + ec_sum([yi*bi for yi,bi in zip(y,list(b)+t1)])
	sigma_tilde = (h, (t2, t3))
	return sigma_tilde


def unblind(params, sigma_tilde, d):
	""" 
	Unblind the credentials. 

	Parameters:
		- `params`: public parameters generated by `setup`
		- `sigma_tilde` (G1Elem, G1Elem): blinded credential
		- `d` (integer): the user's El-Gamal private key

	Returns:
		- `sigma` (G1Elem, G1Elem): unblinded credential
	"""
	(h, c_tilde) = sigma_tilde
	sigma = (h, elgamal_dec(params, d, c_tilde))
	return sigma


def aggregate_sigma(params, sigs, threshold=True):
	""" 
	Aggregate partial credentials. 

	Parameters:
		- `params`: public parameters generated by `setup`
		- `sigs` [(G1Elem, G1Elem)]: array of partial credentials
		- `threshold` (bool): optional, whether to use threshold cryptography or not

	Returns:
		- `aggr_sigma` (G1Elem, G1Elem): aggregated credential
	"""
	(G, o, g1, hs, g2, e) = params
	t = len(sigs)
	# evaluate all lagrange basis polynomial li(0)
	l = [lagrange_basis(t, o, i, 0) for i in range(1,t+1)] if threshold else [1 for _ in range(t)]
	# aggregate sigature
	(h, s) = zip(*sigs)
	aggr_s = ec_sum([l[i]*s[i] for i in range(t)])
	return (h[0], aggr_s)


def randomize(params, sigma):
	"""
	Randomize credentials. 

	Parameters:
		- `params`: public parameters generated by `setup`
		- `sigma` (G1Elem, G1Elem): (aggregated) credential

	Returns:
		- `sigma_prime` (G1Elem, G1Elem): randomized credential
	"""
	(G, o, g1, hs, g2, e) = params
	(h , s) = sigma
	r = o.random()
	sigma_prime = (r*h , r*s)
	return sigma_prime


def show_blind_sign(params, aggr_vk, sigma, private_m):
	"""
	Build cryptographic material for blind verify.

	Parameters:
		- `params`: public parameters generated by `setup`
		- `aggr_vk` (G2Elem, G2Elem, [G2Elem]): aggregated verification key
		- `sigma` (G1Elem, G1Elem): credential
		- `private_m` [Bn]: array containing the private attributes

	Returns:
		- `kappa` (G2Elem): group element to verify the credentials
		- `nu` (G2Elem): group element to verify the credentials
		- `pi_v`: zero-knowledge proof asserting correctness of `kappa` and `nu`
	"""
	assert len(private_m) > 0
	(G, o, g1, hs, g2, e) = params
	(g2, alpha, beta) = aggr_vk
	(h, s) = sigma
	assert len(private_m) <= len(beta)
	t = o.random()
	kappa = t*g2 + alpha + ec_sum([private_m[i]*beta[i] for i in range(len(private_m))])
	nu = t*h
	pi_v = make_pi_v(params, aggr_vk, sigma, private_m, t)
	return (kappa, nu, pi_v)


def blind_verify(params, aggr_vk, sigma, kappa, nu, pi_v, public_m=[]):
	"""
	Verify credentials.

	Parameters:
		- `params`: public parameters generated by `setup`
		- `aggr_vk` (G2Elem, G2Elem, [G2Elem]): aggregated verification key
		- `sigma` (G1Elem, G1Elem): credential
		- `kappa` (G2Elem): group element to verify the credentials
		- `nu` (G2Elem): group element to verify the credentials
		- `pi_v`: zero-knowledge proof asserting correctness of `kappa` and `nu`
		- `public_m` [Bn]: optional, array containing the public attributes

	Returns:
		- `ret` (integrity): whether the credential verifies
	"""
	(G, o, g1, hs, g2, e) = params
	(g2, _, beta) = aggr_vk
	(h, s) = sigma
	private_m_len = len(pi_v[1])
	assert len(public_m)+private_m_len <= len(beta)
	# verify proof of correctness
	assert verify_pi_v(params, aggr_vk, sigma, kappa, nu, pi_v)
	# add clear text messages
	aggr = G2Elem.inf(G) 
	if len(public_m) != 0:
		aggr = ec_sum([public_m[i]*beta[i+private_m_len] for i in range(len(public_m))])
	# verify
	return not h.isinf() and e(h, kappa+aggr) == e(s+nu, g2)


